{
  "problems": [
    {
      "title": "Two Sum",
      "slug": "two-sum",
      "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
      "input_format": "nums: List[int] - An array of integers\ntarget: int - The target sum",
      "output_format": "List[int] - Array of two indices [i, j] where nums[i] + nums[j] == target",
      "difficulty": "Easy",
      "topic_tags": ["Array", "Hash Table"],
      "company_tags": ["Google", "Amazon", "Microsoft"],
      "constraints": "2 ≤ nums.length ≤ 10⁴\n-10⁹ ≤ nums[i] ≤ 10⁹\n-10⁹ ≤ target ≤ 10⁹\nOnly one valid answer exists",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pass",
      "boilerplate_java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "boilerplate_javascript": "var twoSum = function(nums, target) {\n    \n};",
      "test_cases": [
        {
          "input": "nums = [2,7,11,15], target = 9",
          "expected_output": "[0,1]",
          "is_sample": true,
          "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
        },
        {
          "input": "nums = [3,2,4], target = 6",
          "expected_output": "[1,2]",
          "is_sample": true,
          "explanation": "nums[1] + nums[2] == 6"
        },
        {
          "input": "nums = [3,3], target = 6",
          "expected_output": "[0,1]",
          "is_sample": true,
          "explanation": "nums[0] + nums[1] == 6"
        },
        {
          "input": "nums = [-1,-2,-3,-4,-5], target = -8",
          "expected_output": "[2,4]",
          "is_sample": false,
          "explanation": "Testing with negative numbers"
        }
      ],
      "hints": [
        "Try using a hash map to store numbers you've already seen",
        "For each number, check if (target - number) exists in your hash map",
        "The solution can be done in a single pass through the array"
      ]
    },
    {
      "title": "Valid Parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
      "input_format": "s: str - A string containing only bracket characters",
      "output_format": "bool - True if the string is valid, False otherwise",
      "difficulty": "Easy",
      "topic_tags": ["String", "Stack"],
      "company_tags": ["Amazon", "Microsoft", "Facebook"],
      "constraints": "1 ≤ s.length ≤ 10⁴\ns consists of parentheses only '()[]{}'",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def isValid(self, s: str) -> bool:\n        pass",
      "boilerplate_java": "class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};",
      "boilerplate_javascript": "var isValid = function(s) {\n    \n};",
      "test_cases": [
        {
          "input": "s = \"()\"",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "Simple valid pair of parentheses"
        },
        {
          "input": "s = \"()[]{}\"",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "Multiple valid bracket pairs"
        },
        {
          "input": "s = \"(]\"",
          "expected_output": "false",
          "is_sample": true,
          "explanation": "Mismatched bracket types"
        },
        {
          "input": "s = \"([)]\"",
          "expected_output": "false",
          "is_sample": false,
          "explanation": "Incorrect nesting order"
        }
      ],
      "hints": [
        "Use a stack data structure to keep track of opening brackets",
        "When you see a closing bracket, check if it matches the most recent opening bracket",
        "The string is valid only if the stack is empty at the end"
      ]
    },
    {
      "title": "Best Time to Buy and Sell Stock",
      "slug": "best-time-to-buy-and-sell-stock",
      "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.",
      "input_format": "prices: List[int] - Array where prices[i] is the price on day i",
      "output_format": "int - Maximum profit possible (or 0 if no profit can be made)",
      "difficulty": "Easy",
      "topic_tags": ["Array", "Dynamic Programming"],
      "company_tags": ["Amazon", "Google", "Microsoft"],
      "constraints": "1 ≤ prices.length ≤ 10⁵\n0 ≤ prices[i] ≤ 10⁴",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};",
      "boilerplate_javascript": "var maxProfit = function(prices) {\n    \n};",
      "test_cases": [
        {
          "input": "prices = [7,1,5,3,6,4]",
          "expected_output": "5",
          "is_sample": true,
          "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5"
        },
        {
          "input": "prices = [7,6,4,3,1]",
          "expected_output": "0",
          "is_sample": true,
          "explanation": "No transactions are done and the max profit = 0"
        },
        {
          "input": "prices = [2,4,1]",
          "expected_output": "2",
          "is_sample": false,
          "explanation": "Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 2"
        }
      ],
      "hints": [
        "Track the minimum price seen so far as you iterate through the array",
        "For each price, calculate the profit if you sold at that price",
        "Keep track of the maximum profit seen"
      ]
    },
    {
      "title": "Contains Duplicate",
      "slug": "contains-duplicate",
      "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
      "input_format": "nums: List[int] - An array of integers",
      "output_format": "bool - True if any value appears twice, False otherwise",
      "difficulty": "Easy",
      "topic_tags": ["Array", "Hash Table", "Sorting"],
      "company_tags": ["Amazon", "Apple", "Google"],
      "constraints": "1 ≤ nums.length ≤ 10⁵\n-10⁹ ≤ nums[i] ≤ 10⁹",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        pass",
      "boilerplate_java": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        \n    }\n};",
      "boilerplate_javascript": "var containsDuplicate = function(nums) {\n    \n};",
      "test_cases": [
        {
          "input": "nums = [1,2,3,1]",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "The element 1 appears twice"
        },
        {
          "input": "nums = [1,2,3,4]",
          "expected_output": "false",
          "is_sample": true,
          "explanation": "All elements are distinct"
        },
        {
          "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "Multiple duplicates exist"
        }
      ],
      "hints": [
        "Use a hash set to track numbers you've seen",
        "If you encounter a number already in the set, return true",
        "If you finish the loop without finding duplicates, return false"
      ]
    },
    {
      "title": "Maximum Subarray",
      "slug": "maximum-subarray",
      "description": "Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\nA subarray is a contiguous part of an array.",
      "input_format": "nums: List[int] - An array of integers",
      "output_format": "int - The sum of the maximum subarray",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Dynamic Programming", "Divide and Conquer"],
      "company_tags": ["Amazon", "Microsoft", "LinkedIn"],
      "constraints": "1 ≤ nums.length ≤ 10⁵\n-10⁴ ≤ nums[i] ≤ 10⁴",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "points": 15,
      "boilerplate_python": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int maxSubArray(int[] nums) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        \n    }\n};",
      "boilerplate_javascript": "var maxSubArray = function(nums) {\n    \n};",
      "test_cases": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "expected_output": "6",
          "is_sample": true,
          "explanation": "The subarray [4,-1,2,1] has the largest sum of 6"
        },
        {
          "input": "nums = [1]",
          "expected_output": "1",
          "is_sample": true,
          "explanation": "Single element array"
        },
        {
          "input": "nums = [5,4,-1,7,8]",
          "expected_output": "23",
          "is_sample": true,
          "explanation": "The entire array is the maximum subarray"
        }
      ],
      "hints": [
        "This is a classic dynamic programming problem (Kadane's Algorithm)",
        "Keep track of the maximum sum ending at the current position",
        "At each position, decide whether to extend the previous subarray or start a new one"
      ]
    },
    {
      "title": "Merge Two Sorted Lists",
      "slug": "merge-two-sorted-lists",
      "description": "You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
      "input_format": "list1: Optional[ListNode] - Head of first sorted linked list\nlist2: Optional[ListNode] - Head of second sorted linked list",
      "output_format": "Optional[ListNode] - Head of the merged sorted linked list",
      "difficulty": "Easy",
      "topic_tags": ["Linked List", "Recursion"],
      "company_tags": ["Amazon", "Microsoft", "Adobe"],
      "constraints": "The number of nodes in both lists is in the range [0, 50]\n-100 ≤ Node.val ≤ 100\nBoth list1 and list2 are sorted in non-decreasing order",
      "time_complexity": "O(n + m)",
      "space_complexity": "O(1)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        pass",
      "boilerplate_java": "class Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        \n    }\n};",
      "boilerplate_javascript": "var mergeTwoLists = function(list1, list2) {\n    \n};",
      "test_cases": [
        {
          "input": "list1 = [1,2,4], list2 = [1,3,4]",
          "expected_output": "[1,1,2,3,4,4]",
          "is_sample": true,
          "explanation": "Merge both lists maintaining sorted order"
        },
        {
          "input": "list1 = [], list2 = []",
          "expected_output": "[]",
          "is_sample": true,
          "explanation": "Both lists are empty"
        },
        {
          "input": "list1 = [], list2 = [0]",
          "expected_output": "[0]",
          "is_sample": true,
          "explanation": "One list is empty"
        }
      ],
      "hints": [
        "Use a dummy node to simplify edge cases",
        "Compare the current nodes of both lists and append the smaller one",
        "Move the pointer forward in the list from which you took the node"
      ]
    },
    {
      "title": "Reverse Linked List",
      "slug": "reverse-linked-list",
      "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
      "input_format": "head: Optional[ListNode] - The head of the linked list",
      "output_format": "Optional[ListNode] - The head of the reversed linked list",
      "difficulty": "Easy",
      "topic_tags": ["Linked List", "Recursion"],
      "company_tags": ["Amazon", "Microsoft", "Facebook"],
      "constraints": "The number of nodes in the list is the range [0, 5000]\n-5000 ≤ Node.val ≤ 5000",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pass",
      "boilerplate_java": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        \n    }\n};",
      "boilerplate_javascript": "var reverseList = function(head) {\n    \n};",
      "test_cases": [
        {
          "input": "head = [1,2,3,4,5]",
          "expected_output": "[5,4,3,2,1]",
          "is_sample": true,
          "explanation": "Reverse the entire list"
        },
        {
          "input": "head = [1,2]",
          "expected_output": "[2,1]",
          "is_sample": true,
          "explanation": "Reverse a two-node list"
        },
        {
          "input": "head = []",
          "expected_output": "[]",
          "is_sample": true,
          "explanation": "Empty list remains empty"
        }
      ],
      "hints": [
        "Keep track of three pointers: previous, current, and next",
        "Reverse the link direction as you traverse the list",
        "Can also be solved elegantly using recursion"
      ]
    },
    {
      "title": "Invert Binary Tree",
      "slug": "invert-binary-tree",
      "description": "Given the `root` of a binary tree, invert the tree, and return its root.\n\nInverting a binary tree means swapping the left and right children of all nodes in the tree.",
      "input_format": "root: Optional[TreeNode] - The root of the binary tree",
      "output_format": "Optional[TreeNode] - The root of the inverted tree",
      "difficulty": "Easy",
      "topic_tags": ["Tree", "Depth-First Search", "Breadth-First Search", "Binary Tree"],
      "company_tags": ["Google", "Amazon", "Microsoft"],
      "constraints": "The number of nodes in the tree is in the range [0, 100]\n-100 ≤ Node.val ≤ 100",
      "time_complexity": "O(n)",
      "space_complexity": "O(h)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        pass",
      "boilerplate_java": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        \n    }\n};",
      "boilerplate_javascript": "var invertTree = function(root) {\n    \n};",
      "test_cases": [
        {
          "input": "root = [4,2,7,1,3,6,9]",
          "expected_output": "[4,7,2,9,6,3,1]",
          "is_sample": true,
          "explanation": "Invert the tree by swapping left and right subtrees"
        },
        {
          "input": "root = [2,1,3]",
          "expected_output": "[2,3,1]",
          "is_sample": true,
          "explanation": "Simple tree inversion"
        },
        {
          "input": "root = []",
          "expected_output": "[]",
          "is_sample": true,
          "explanation": "Empty tree"
        }
      ],
      "hints": [
        "Use recursion to swap left and right children of each node",
        "Can also use BFS or DFS iteratively with a queue/stack",
        "Remember to recursively invert both subtrees"
      ]
    },
    {
      "title": "Binary Search",
      "slug": "binary-search",
      "description": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`.\n\nIf `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
      "input_format": "nums: List[int] - Sorted array of integers\ntarget: int - The target value to search for",
      "output_format": "int - Index of target if found, -1 otherwise",
      "difficulty": "Easy",
      "topic_tags": ["Array", "Binary Search"],
      "company_tags": ["Amazon", "Google", "Facebook"],
      "constraints": "1 ≤ nums.length ≤ 10⁴\n-10⁴ < nums[i], target < 10⁴\nAll integers in nums are unique\nnums is sorted in ascending order",
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};",
      "boilerplate_javascript": "var search = function(nums, target) {\n    \n};",
      "test_cases": [
        {
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "expected_output": "4",
          "is_sample": true,
          "explanation": "9 exists in nums and its index is 4"
        },
        {
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "expected_output": "-1",
          "is_sample": true,
          "explanation": "2 does not exist in nums so return -1"
        },
        {
          "input": "nums = [5], target = 5",
          "expected_output": "0",
          "is_sample": false,
          "explanation": "Single element array"
        }
      ],
      "hints": [
        "Use two pointers (left and right) to define the search space",
        "Compare the middle element with the target",
        "Eliminate half of the search space in each iteration"
      ]
    },
    {
      "title": "Climbing Stairs",
      "slug": "climbing-stairs",
      "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "input_format": "n: int - Number of steps to reach the top",
      "output_format": "int - Number of distinct ways to climb to the top",
      "difficulty": "Easy",
      "topic_tags": ["Math", "Dynamic Programming", "Memoization"],
      "company_tags": ["Amazon", "Adobe", "Google"],
      "constraints": "1 ≤ n ≤ 45",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};",
      "boilerplate_javascript": "var climbStairs = function(n) {\n    \n};",
      "test_cases": [
        {
          "input": "n = 2",
          "expected_output": "2",
          "is_sample": true,
          "explanation": "Two ways: 1. 1 step + 1 step, 2. 2 steps"
        },
        {
          "input": "n = 3",
          "expected_output": "3",
          "is_sample": true,
          "explanation": "Three ways: 1+1+1, 1+2, 2+1"
        },
        {
          "input": "n = 5",
          "expected_output": "8",
          "is_sample": false,
          "explanation": "Eight distinct ways to climb 5 stairs"
        }
      ],
      "hints": [
        "This is similar to the Fibonacci sequence",
        "To reach step n, you could come from step n-1 or step n-2",
        "Use dynamic programming or space-optimized approach with two variables"
      ]
    },
    {
      "title": "Longest Substring Without Repeating Characters",
      "slug": "longest-substring-without-repeating-characters",
      "description": "Given a string `s`, find the length of the longest substring without repeating characters.\n\nA substring is a contiguous non-empty sequence of characters within a string.",
      "input_format": "s: str - Input string",
      "output_format": "int - Length of the longest substring without repeating characters",
      "difficulty": "Medium",
      "topic_tags": ["Hash Table", "String", "Sliding Window"],
      "company_tags": ["Amazon", "Google", "Facebook"],
      "constraints": "0 ≤ s.length ≤ 5 * 10⁴\ns consists of English letters, digits, symbols and spaces",
      "time_complexity": "O(n)",
      "space_complexity": "O(min(n, m))",
      "points": 15,
      "boilerplate_python": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n    }\n};",
      "boilerplate_javascript": "var lengthOfLongestSubstring = function(s) {\n    \n};",
      "test_cases": [
        {
          "input": "s = \"abcabcbb\"",
          "expected_output": "3",
          "is_sample": true,
          "explanation": "The answer is 'abc', with length 3"
        },
        {
          "input": "s = \"bbbbb\"",
          "expected_output": "1",
          "is_sample": true,
          "explanation": "The answer is 'b', with length 1"
        },
        {
          "input": "s = \"pwwkew\"",
          "expected_output": "3",
          "is_sample": true,
          "explanation": "The answer is 'wke', with length 3"
        },
        {
          "input": "s = \"\"",
          "expected_output": "0",
          "is_sample": false,
          "explanation": "Empty string"
        }
      ],
      "hints": [
        "Use the sliding window technique with two pointers",
        "Keep a hash set or hash map to track characters in the current window",
        "When you find a duplicate, shrink the window from the left"
      ]
    },
    {
      "title": "3Sum",
      "slug": "3sum",
      "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
      "input_format": "nums: List[int] - Array of integers",
      "output_format": "List[List[int]] - List of unique triplets that sum to zero",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Two Pointers", "Sorting"],
      "company_tags": ["Amazon", "Facebook", "Microsoft"],
      "constraints": "3 ≤ nums.length ≤ 3000\n-10⁵ ≤ nums[i] ≤ 10⁵",
      "time_complexity": "O(n²)",
      "space_complexity": "O(1)",
      "points": 20,
      "boilerplate_python": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        pass",
      "boilerplate_java": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n    }\n};",
      "boilerplate_javascript": "var threeSum = function(nums) {\n    \n};",
      "test_cases": [
        {
          "input": "nums = [-1,0,1,2,-1,-4]",
          "expected_output": "[[-1,-1,2],[-1,0,1]]",
          "is_sample": true,
          "explanation": "The distinct triplets that sum to 0"
        },
        {
          "input": "nums = [0,1,1]",
          "expected_output": "[]",
          "is_sample": true,
          "explanation": "No triplets sum to 0"
        },
        {
          "input": "nums = [0,0,0]",
          "expected_output": "[[0,0,0]]",
          "is_sample": false,
          "explanation": "All zeros"
        }
      ],
      "hints": [
        "Sort the array first to make it easier to avoid duplicates",
        "Fix one element and use two pointers for the remaining two",
        "Skip duplicate values to avoid duplicate triplets"
      ]
    },
    {
      "title": "Product of Array Except Self",
      "slug": "product-of-array-except-self",
      "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
      "input_format": "nums: List[int] - Array of integers",
      "output_format": "List[int] - Array where answer[i] = product of all elements except nums[i]",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Prefix Sum"],
      "company_tags": ["Amazon", "Microsoft", "Facebook"],
      "constraints": "2 ≤ nums.length ≤ 10⁵\n-30 ≤ nums[i] ≤ 30\nThe product of any prefix or suffix is guaranteed to fit in a 32-bit integer",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "points": 20,
      "boilerplate_python": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        pass",
      "boilerplate_java": "class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        \n    }\n};",
      "boilerplate_javascript": "var productExceptSelf = function(nums) {\n    \n};",
      "test_cases": [
        {
          "input": "nums = [1,2,3,4]",
          "expected_output": "[24,12,8,6]",
          "is_sample": true,
          "explanation": "Product except self: [2*3*4, 1*3*4, 1*2*4, 1*2*3]"
        },
        {
          "input": "nums = [-1,1,0,-3,3]",
          "expected_output": "[0,0,9,0,0]",
          "is_sample": true,
          "explanation": "When 0 is present in array"
        }
      ],
      "hints": [
        "Calculate prefix products (product of all elements before i)",
        "Calculate suffix products (product of all elements after i)",
        "Multiply prefix and suffix for each position"
      ]
    },
    {
      "title": "Merge Intervals",
      "slug": "merge-intervals",
      "description": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
      "input_format": "intervals: List[List[int]] - Array of intervals",
      "output_format": "List[List[int]] - Array of merged non-overlapping intervals",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Sorting"],
      "company_tags": ["Google", "Facebook", "Amazon"],
      "constraints": "1 ≤ intervals.length ≤ 10⁴\nintervals[i].length == 2\n0 ≤ starti ≤ endi ≤ 10⁴",
      "time_complexity": "O(n log n)",
      "space_complexity": "O(n)",
      "points": 20,
      "boilerplate_python": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        pass",
      "boilerplate_java": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        \n    }\n};",
      "boilerplate_javascript": "var merge = function(intervals) {\n    \n};",
      "test_cases": [
        {
          "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
          "expected_output": "[[1,6],[8,10],[15,18]]",
          "is_sample": true,
          "explanation": "Intervals [1,3] and [2,6] overlap, merge to [1,6]"
        },
        {
          "input": "intervals = [[1,4],[4,5]]",
          "expected_output": "[[1,5]]",
          "is_sample": true,
          "explanation": "Intervals touch at 4, merge to [1,5]"
        }
      ],
      "hints": [
        "Sort intervals by their start time",
        "Iterate through sorted intervals and merge when they overlap",
        "Two intervals overlap if start of second ≤ end of first"
      ]
    },
    {
      "title": "Group Anagrams",
      "slug": "group-anagrams",
      "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "input_format": "strs: List[str] - Array of strings",
      "output_format": "List[List[str]] - Grouped anagrams",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Hash Table", "String", "Sorting"],
      "company_tags": ["Amazon", "Microsoft", "Facebook"],
      "constraints": "1 ≤ strs.length ≤ 10⁴\n0 ≤ strs[i].length ≤ 100\nstrs[i] consists of lowercase English letters",
      "time_complexity": "O(n * k log k)",
      "space_complexity": "O(n * k)",
      "points": 15,
      "boilerplate_python": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        pass",
      "boilerplate_java": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        \n    }\n};",
      "boilerplate_javascript": "var groupAnagrams = function(strs) {\n    \n};",
      "test_cases": [
        {
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "expected_output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
          "is_sample": true,
          "explanation": "Group words that are anagrams of each other"
        },
        {
          "input": "strs = [\"\"]",
          "expected_output": "[[\"\"]]",
          "is_sample": true,
          "explanation": "Empty string"
        },
        {
          "input": "strs = [\"a\"]",
          "expected_output": "[[\"a\"]]",
          "is_sample": true,
          "explanation": "Single character"
        }
      ],
      "hints": [
        "Use sorted string as a key in a hash map",
        "All anagrams will have the same sorted string",
        "Group strings with the same key together"
      ]
    },
    {
      "title": "Valid Palindrome",
      "slug": "valid-palindrome",
      "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
      "input_format": "s: str - Input string",
      "output_format": "bool - True if palindrome, False otherwise",
      "difficulty": "Easy",
      "topic_tags": ["Two Pointers", "String"],
      "company_tags": ["Facebook", "Amazon", "Microsoft"],
      "constraints": "1 ≤ s.length ≤ 2 * 10⁵\ns consists only of printable ASCII characters",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "points": 10,
      "boilerplate_python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        pass",
      "boilerplate_java": "class Solution {\n    public boolean isPalindrome(String s) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    bool isPalindrome(string s) {\n        \n    }\n};",
      "boilerplate_javascript": "var isPalindrome = function(s) {\n    \n};",
      "test_cases": [
        {
          "input": "s = \"A man, a plan, a canal: Panama\"",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "After processing: 'amanaplanacanalpanama' is a palindrome"
        },
        {
          "input": "s = \"race a car\"",
          "expected_output": "false",
          "is_sample": true,
          "explanation": "'raceacar' is not a palindrome"
        },
        {
          "input": "s = \" \"",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "Empty string after processing is considered palindrome"
        }
      ],
      "hints": [
        "Use two pointers from both ends",
        "Skip non-alphanumeric characters",
        "Compare characters in lowercase"
      ]
    },
    {
      "title": "Longest Palindromic Substring",
      "slug": "longest-palindromic-substring",
      "description": "Given a string `s`, return the longest palindromic substring in `s`.\n\nA string is palindromic if it reads the same forward and backward.",
      "input_format": "s: str - Input string",
      "output_format": "str - The longest palindromic substring",
      "difficulty": "Medium",
      "topic_tags": ["String", "Dynamic Programming"],
      "company_tags": ["Amazon", "Microsoft", "Adobe"],
      "constraints": "1 ≤ s.length ≤ 1000\ns consist of only digits and English letters",
      "time_complexity": "O(n²)",
      "space_complexity": "O(1)",
      "points": 20,
      "boilerplate_python": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        pass",
      "boilerplate_java": "class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "boilerplate_javascript": "var longestPalindrome = function(s) {\n    \n};",
      "test_cases": [
        {
          "input": "s = \"babad\"",
          "expected_output": "\"bab\"",
          "is_sample": true,
          "explanation": "'aba' is also a valid answer"
        },
        {
          "input": "s = \"cbbd\"",
          "expected_output": "\"bb\"",
          "is_sample": true,
          "explanation": "The longest palindrome is 'bb'"
        }
      ],
      "hints": [
        "Expand around each possible center (character or between characters)",
        "For each center, expand while characters match",
        "Keep track of the longest palindrome found"
      ]
    },
    {
      "title": "Course Schedule",
      "slug": "course-schedule",
      "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
      "input_format": "numCourses: int - Total number of courses\nprerequisites: List[List[int]] - Prerequisites array",
      "output_format": "bool - True if can finish all courses, False otherwise",
      "difficulty": "Medium",
      "topic_tags": ["Depth-First Search", "Breadth-First Search", "Graph", "Topological Sort"],
      "company_tags": ["Amazon", "Microsoft", "Google"],
      "constraints": "1 ≤ numCourses ≤ 2000\n0 ≤ prerequisites.length ≤ 5000\nprerequisites[i].length == 2\n0 ≤ ai, bi < numCourses\nAll pairs are unique",
      "time_complexity": "O(V + E)",
      "space_complexity": "O(V + E)",
      "points": 25,
      "boilerplate_python": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        pass",
      "boilerplate_java": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};",
      "boilerplate_javascript": "var canFinish = function(numCourses, prerequisites) {\n    \n};",
      "test_cases": [
        {
          "input": "numCourses = 2, prerequisites = [[1,0]]",
          "expected_output": "true",
          "is_sample": true,
          "explanation": "Take course 0 first, then course 1"
        },
        {
          "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
          "expected_output": "false",
          "is_sample": true,
          "explanation": "Circular dependency - cannot finish"
        }
      ],
      "hints": [
        "This is a cycle detection problem in a directed graph",
        "Use DFS with color marking (white, gray, black)",
        "Or use topological sort (Kahn's algorithm) with BFS"
      ]
    },
    {
      "title": "Number of Islands",
      "slug": "number-of-islands",
      "description": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
      "input_format": "grid: List[List[str]] - 2D grid of '1's and '0's",
      "output_format": "int - Number of islands",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Depth-First Search", "Breadth-First Search", "Union Find", "Matrix"],
      "company_tags": ["Amazon", "Facebook", "Google"],
      "constraints": "m == grid.length\nn == grid[i].length\n1 ≤ m, n ≤ 300\ngrid[i][j] is '0' or '1'",
      "time_complexity": "O(m * n)",
      "space_complexity": "O(m * n)",
      "points": 20,
      "boilerplate_python": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int numIslands(char[][] grid) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        \n    }\n};",
      "boilerplate_javascript": "var numIslands = function(grid) {\n    \n};",
      "test_cases": [
        {
          "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
          "expected_output": "1",
          "is_sample": true,
          "explanation": "All connected 1's form one island"
        },
        {
          "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
          "expected_output": "3",
          "is_sample": true,
          "explanation": "Three separate islands"
        }
      ],
      "hints": [
        "Use DFS or BFS to explore each island",
        "Mark visited cells to avoid counting the same island twice",
        "Increment counter for each new island found"
      ]
    },
    {
      "title": "Coin Change",
      "slug": "coin-change",
      "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
      "input_format": "coins: List[int] - Array of coin denominations\namount: int - Target amount",
      "output_format": "int - Minimum number of coins needed, or -1 if impossible",
      "difficulty": "Medium",
      "topic_tags": ["Array", "Dynamic Programming", "Breadth-First Search"],
      "company_tags": ["Amazon", "Google", "Microsoft"],
      "constraints": "1 ≤ coins.length ≤ 12\n1 ≤ coins[i] ≤ 2³¹ - 1\n0 ≤ amount ≤ 10⁴",
      "time_complexity": "O(amount * n)",
      "space_complexity": "O(amount)",
      "points": 25,
      "boilerplate_python": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        pass",
      "boilerplate_java": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        \n    }\n}",
      "boilerplate_cpp": "class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        \n    }\n};",
      "boilerplate_javascript": "var coinChange = function(coins, amount) {\n    \n};",
      "test_cases": [
        {
          "input": "coins = [1,2,5], amount = 11",
          "expected_output": "3",
          "is_sample": true,
          "explanation": "11 = 5 + 5 + 1 (3 coins)"
        },
        {
          "input": "coins = [2], amount = 3",
          "expected_output": "-1",
          "is_sample": true,
          "explanation": "Cannot make amount 3 with only coin of 2"
        },
        {
          "input": "coins = [1], amount = 0",
          "expected_output": "0",
          "is_sample": true,
          "explanation": "0 coins needed for amount 0"
        }
      ],
      "hints": [
        "Use dynamic programming with dp[i] = minimum coins needed for amount i",
        "For each amount, try all coin denominations",
        "dp[i] = min(dp[i], dp[i - coin] + 1) for each coin"
      ]
    }
  ]
}